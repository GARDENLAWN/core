<?php
/**
 * Plugin to replace the standard <img> tag generated by the product image block
 * with a responsive <picture> element supporting AVIF and WebP formats.
 */
declare(strict_types=1);

namespace GardenLawn\Core\Plugin\Catalog\Block\Product;

use Magento\Catalog\Block\Product\Image as Subject;
use Magento\Framework\App\Filesystem\DirectoryList;
use Magento\Framework\Filesystem;
use Magento\Framework\UrlInterface;
use Magento\Framework\View\Design\Theme\Image\Uploader;

class Image
{
    private const array IMAGE_FORMATS = ['avif', 'webp'];

    /**
     * @var Filesystem
     */
    private Filesystem $filesystem;

    /**
     * @var UrlInterface
     */
    private UrlInterface $urlBuilder;

    /**
     * @var Uploader
     */
    private $imageUploader;

    /**
     * @param Filesystem $filesystem
     * @param UrlInterface $urlBuilder
     * @param Uploader $imageUploader
     */
    public function __construct(
        Filesystem $filesystem,
        UrlInterface $urlBuilder,
        Uploader $imageUploader // Wymagany do uzyskania ścieżek
    ) {
        $this->filesystem = $filesystem;
        $this->urlBuilder = $urlBuilder;
        $this->imageUploader = $imageUploader;
    }

    /**
     * Around plugin for toHtml() to generate <picture> tag instead of <img>.
     * NOTE: This is an illustrative example. In a real module, you would primarily
     * use logic from a Helper to check file existence and generate the full HTML.
     *
     * @param Subject $subject
     * @param callable $proceed
     * @return string
     * @SuppressWarnings(PHPMD.UnusedFormalParameter)
     */
    public function aroundToHtml(
        Subject $subject,
        callable $proceed
    ): string {
        try {
            // Pobranie URL oryginalnego obrazu (np. JPG/PNG)
            $originalImageUrl = $subject->getImageUrl();
            if (empty($originalImageUrl)) {
                return $proceed(); // Jeśli URL jest pusty, użyj oryginalnej metody
            }

            // Użyj oryginalnego bloku do wygenerowania tagu <img>, aby uzyskać wszystkie
            // atrybuty (width, height, class, alt)
            $imgHtml = $proceed();

            // Pobierz ścieżkę do pliku w systemie plików (ważne do sprawdzenia istnienia)
            $mediaDirectory = $this->filesystem->getDirectoryRead(DirectoryList::MEDIA);
            $mediaUrl = $this->urlBuilder->getBaseUrl(['_type' => UrlInterface::URL_TYPE_MEDIA]);
            $originalRelativePath = str_replace($mediaUrl, '', $originalImageUrl);

            $sourceHtml = '';
            $hasModernSource = false;

            // 1. Sprawdź i wygeneruj tagi <source> dla WebP i AVIF
            foreach (self::IMAGE_FORMATS as $format) {
                $alternativeRelativePath = $originalRelativePath . '.' . $format;

                // Sprawdź, czy alternatywny plik istnieje na dysku
                if ($mediaDirectory->isExist($alternativeRelativePath)) {
                    $alternativeUrl = $mediaUrl . $alternativeRelativePath;
                    $mimeType = 'image/' . $format;

                    // Dodaj tag <source>
                    $sourceHtml .= sprintf(
                        '<source srcset="%s" type="%s">',
                        $alternativeUrl,
                        $mimeType
                    );
                    $hasModernSource = true;
                }
            }

            // Jeśli znaleziono nowoczesne formaty, otocz <img> tagiem <picture>
            if ($hasModernSource) {
                return sprintf(
                    '<picture>%s%s</picture>',
                    $sourceHtml,
                    $imgHtml
                );
            }

            return $imgHtml; // Zwróć tylko <img>, jeśli nie ma nowoczesnych formatów
        } catch (\Exception $e) {
            // W razie błędu zwróć oryginalny HTML i zaloguj błąd
            // $this->logger->error($e->getMessage()); // Wymagałoby wstrzyknięcia Loggera
            return $proceed();
        }
    }
}
